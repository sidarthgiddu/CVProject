Title         : _eye_ROBOT -­ HETEROGENEOUS ROBOTIC PLATFORM FOR REAL-­TIME COMPUTER VISION
Subtitle      : A Comprehensive Tutorial 
Heading Base  : 2
Logo          : false
Author        : Danlu Huang

[TITLE]

# Introduction
## Motivation
The motivation of this project is to explore the field of heterogeneous computing using High-Level Digital Synthesis (HLS). We wanted to build a system which can use FPGA as an accelerator along with the main processor and communicate with the outside world. As a specific application, we have programmed the FPGA to detect the video gesture from HDMI camera and send the commands to iRobot to drive in desired direction. As video processing on real-time HD video stream is slow on normal processor, we used FPGA as an accelerator to offload some of the work from processor. This project involves many aspects of hardware-software co-designing like HLS, Embedded Programming, Computer Vision and FPGA prototyping, making it an ideal project for students in Electrical and Computer Engineering field. 

## Overview
<p>
In this design, the camera input is fed to the processing unit which can either be a computer, running software or an FPGA running heterogenous programs. The processing unit interprets the commands from the input video and sends it to the wireless access point. The wireless access point is used to broadcast the commands to Intel Galileo. Intel Galileo has an wireless receptor named Intel N135, which is responsible to receive the commands sent by access point. Intel Galileo receives the command from the wireless receptor and sends it to the iRobot over UART serial link operating at 57600 baud rate. The overall high-level design of the project is shown in Figure 1.
</p>
~ Center
~~ Figure { #fig-design caption="Abstract Design of Project Objective." }
![design_flow]
~~
~
[design_flow]: images/design_flow.jpg "design_flow" { width=auto max-width=90% }

## System of Requirements
Heterogeneous programming on FPGA using HLS is the priority of the project. Following were the
system of requirements which we targeted throughout the project.

* All hardware programming should be done in high-level programming language like C++ without Verilog coding involved
* FPGA fabric should be used as an accelerator along with the main processor
* Significant workload has to be given to FPGA so that the computation supersedes the communication overhead between processor and FPGA.
* Vision based gesture recognition algorithm should be implemented on Xilinx Zynq FPGA.
* FPGA should be able to process HDMI video frames in real-time.
* The heterogeneous core on FPGA should be able to communicate with iRobot over wireless channel.
* Performance of the heterogeneous system should be faster than that of software implementation.
* iRobot should be controlled by Intel Galileo microcontroller to take in the commands
* iRobot should be controlled smoothly and intuitively based on the gesture provided by user

# Development Approach
We followed hierarchical and modular development approach. As the project involved fair amount of
complexity, we divided the project into 2 major categories: (1) Software Design and (2) Hardware
Design. Software Design was meant to develop software version of entire project. This includes camera capture, gesture recognition and command sending on Intel i3 processor, programming Intel Galileo to receive the command and send it to iRobot for driving. The hardware design was meant to develop heterogeneous core which replaces software version of video capture, gesture recognition and command sending units. We managed to finish software design in Fall semester and hardware
development in Spring semester. As the software version is relatively easier than developing project on hardware, our approach helped us unblock major issues of the project earlier in the design cycle.
<dev>
The incremental development approach from pure software to software-hardware co-design is demonstrated in this diagram: 
</dev>
~ Center
~~ Figure  { #fig-design caption="Incremental Development Approach" } 
![figure2]
~~
~
[figure2]: images/figure2.jpg "figure2" { width=auto max-width=90% }

<div>
In the follwing sections, you will see detailed instructions on how to proceed from each step to the next, including how to download and setup the required softwares and hardwares, how to operate on them, how to run the codes, along with screenshots and important notices for troubleshooting. 
</div>

# Tutorials
## Direct communication between iRobot and Computer
Before using Intel Galileo to control the iRobot, we can first use a serial cable to control iRobot directly from our laptop by using Open Interface commands of iRobot. This will help you become familiar with the serial codes used for iRobot.

1. Read [Owner's guide] and [Open Interface] to learn OI commands in iRobot. \
Owner's guide provides some general introduction of iRobots and have some sample serial codes, while Open Interface serves as a reference of all serial codes and ports. You can also look at this tutorial "[iRobot Create: Getting Started]".
[Owner's guide]: http://www.irobot.com/filelibrary/pdfs/hrd/create/Create%20Manual_Final.pdf
[Open Interface]: http://www.irobot.com/filelibrary/pdfs/hrd/create/Create%20Open%20Interface_v2.pdf
[iRobot Create: Getting Started]: http://projectsfromtech.blogspot.com/2013/11/irobot-create-getting-started.html 

2. Connect iRobot to your computer. \
In order to connect iRobot with the computer, we need to use the serial cable that comes with iRobot. \
If your laptop can only  connect to an USB port, you will need to connect the serial cable with another USB to RS-232 DB9 Serial Converter. The USB port should be connected with the Serial Port of iRobot, which is shown in Figure 3.
~ Center
~~Figure { #fig-design caption="Top View of iRobot" }
![iRobot_top_view]
~~
~
[iRobot_top_view]: images/iRobot_top_view.jpg "iRobot_top_view" { width=auto max-width=90% }

3. Download [Realterm] for serial port control. 
[Realterm]: http://sourceforge.net/projects/realterm/files/
_Realterm_ is a serial terminal used for debugging and development of external devices. Here is a screenshot of the window:
~ Center
~~ Figure { #fig-design caption="Realterm Window" }
![realterm]
~~
~
[realterm]: images/realterm.jpg "realterm" { width=auto max-width=90% }

4. Go to **Port** tab and select the port that iRobot is connected to. 
5. Configure the serial settings to 57600 baud, 8 data bits, 1 stop bit and no flow control. 
Note: 57600 baud is the default baud rate for iRobot.
6. Go to **Send** tab to enter OI commands as shown below:
~ Center
~~ Figure { #fig-design caption="Sending OI Commands" }
![realterm2]
~~
~
[realterm2]: images/realterm2.jpg "realterm2" { width=auto max-width=90% }
7. Click **Send Numbers** to send the commands to iRobot. \
You can always refer to Open Interface for complete explanations of all serial codes and use the examples to test your iRobot. 

## Smooth controlling of iRobot with keyboard
In this section, we are going to incorporate the Intel Galileo board and a local WPA network to control the iRobot with the direction keys on your keyboard and send commands wirelessly. 
### Getting to know your board
To begin with, you might find it very helpful to learn about the basics of your board before we start. \
~ Center
~~ Figure { #fig-design caption="Overview of Intel Galileo" }
![image008]
~~
~
[image008]: images/image008.jpg "image008" { width=auto max-width=90% }

Intel Galileo is a microcontroller board based on Intel x86 architecture and featuring the Intel 
Quark SoC X1000 Application Processor. Developed by Intel Corporation, Galileo is the first Arduino-certified development board that combines Intel technology and the support for Arduino hardware expansion cards called "sheilds" designed for the Arduino Uno R3. From a hardware perspective, this means that all of its major pins and headers are in the same locations as on the Arduino Uno R3; from a software perspective, this means that Intel Galileo, running an open-source Linux operating system, can be programmed through the Arduino Integrated Development Environment (IDE) and make use of the existing libraries and software programs (usually called "sketches"). A full-sized mini-PCI Express slot, 100 Mb Ethernet port, Micro-SD slot, 6-pin 3.3V USB TTL UART header, USB host port, USB client port, and 8 Mbyte NOR Flash come standard on the board. Galileo has a number of facilities for communicating with a computer, another Arduino, or other microcontrollers. Galileo provides UART TTL (5V/3.3V) serial communication, which is available on digital pin 0 (RX) and 1 (TX). In addition, a second UART provides RS-232 support and is connected via a 3.5mm jack. The USB Device ports allows for serial (CDC) communications over USB. This provides a serial connection to the Serial Monitor or other applications on your computer. 

You can find some important information about its properties from here: 

General Overview: [Arduino - Intel Galileo] <br>
Datasheet and Schematics: [Galileo Schematic] <br>
Starter Guide: [Galileo Getting Started Guide]
[Arduino - Intel Galileo]: http://www.arduino.cc/en/ArduinoCertified/IntelGalileo 
[Galileo Schematic]: http://download.intel.com/support/galileo/sb/galileo_schematic.pdf
[Galileo Getting Started Guide]: https://learn.sparkfun.com/tutorials/galileo-getting-started-guide#software-downloadsetup

### Software Setup: Arduino IDE
In order to upload Arduino sketches to Intel Galileo, we need the Arduino IDE (integrated development environment). Unfortunately, the Galileo will not work with the standard IDEs, so we will have to download and install one of the specialized versions that is compatible with Galileo. Qualified versions include 1.5.3 and 1.6.0 or newer ones. \

The tutorial below is mainly based on Windows system. You can see a comprehensive collection of instructions for all OS and IDE in the [Getting Started Guide] on the website of Intel. Once you open this website, choose your OS in the first drop-down menu and select "Arduino" as IDE in the second drop-down menu to proceed. 
[Getting Started Guide]: https://software.intel.com/en-us/iot/library/galileo-getting-started 

1. Go to the [download center]. Select the download option for one of the qualified versions mentioned above and 
your computer's operating system. \
Note: version 1.5.3 has a limitation with the language of OS. If your computer is running on an OS that uses a language other than English, try changing it to English from Control Panel, or you can download version 1.6.0 or newer. 

[download center]: http://www.intel.com/support/galileo/sb/CS-035101.htm
~ Center
~~ Figure { #fig-design caption="Arduino Software download" }
![arduino_ide_download]
~~
~
[arduino_ide_download]: images/arduino_ide_download.jpg "arduino_ide_download" { width=auto max-width=90% }

2. To enable the Wi-Fi drivers and sketch persistent, download the software for SD-card Linux Image from here: <br><br>
~ Center 
~~ Figure { #fig-design caption="Software for SD-card Linux Image" }
![linuxcard]
~~
~
[linuxcard]: images/linuxcard.jpg "linuxcard" { width=auto max-width=90%}

3. To install Arduino IDE, we need to unzip all files to C:\ directory. Make sure to preserve the folder structure. Here is a screenshot based on Windows machine: <br><br>
~ Center
~~ Figure { #fig-design caption="Install Arduino IDE" }
![arduinofolder]
~~
~
[arduinofolder]: images/arduinofolder.jpg "arduinofolder" { width=auto max-width=90% }

4. Now we are connecting the board to your computer. If you have a micro-SD card in your board, remove it. Connect the power and USB Client port (the USB port closest to Ethernet) to your computer through serial cable, as shown below. Remember to always plug in the power supply before the USB cable, and wait until USB LED lights up to connect the cable, otherwise you may damage the board.
~ Center
~~Figure { #fig-design caption="Connecting Intel Galileo to Your Computer" }
![setup_plug]
~~
~
[setup_plug]: images/setup_plug.jpg "setup_plug" { width=auto max-width=90%}

5. Install and Run Firmware Updater tool \
In your computer, follow **Start > Control Panel > System > Device Manager**. \
Go down to find **Ports (COM & LPT)**. If not, go to **Other Devices**. \
You should see an open port named **Gadget Serial V2.4** (if the board contains an old release like v0.7.5), or simply **Galileo** on newer releases. Right click and select "**Update Driver Software**". \
Choose "**Browse my computer for driver software**". Navigate to **hardware/arduino/x86/tools** directory. Once it is installed properly, you should see something similar to the following screenshot: \
~Center
~~ Figure { #fig-design caption="Update Driver Software" }
![image010]
~~
~
[image010]: images/image010.jpg "image010" { width=auto max-width=90% }

You can also find more information from this link: "[IntelÂ® Galileo Board Assembly using Arduino]"
[IntelÂ® Galileo Board Assembly using Arduino]: https://software.intel.com/en-us/articles/intel-galileo-board-assembly 

6. Update firmware. \
Launch the Arduino IDE. It is under the directory "C:\arduino-1.6.0+Intel" (or a similar name if you have a different version installed), double click "**arduino.exe**"". You should see the following interface: \
~Center 
~~ Figure { #fig-design caption="Firmware Update" }
![arduino_interface]
~~
~
[arduino_interface]: images/arduino_interface.jpg "arduino_interface" { width=auto max-width=90% }
Under **Help** tab, select "**Firmware Update**". It will take few minutes to update firmware on board, and you should have power connected all the time. The board itself usually comes with an older version, which may have unexpected outcomes in the future if you do not update it. 

7. Upload programs\
Under the **Tools** tab, select the type of board you are using (in this case, Intel Galileo) in **Board** and "COMx" ("x"" is a number depending on the USB port on your computer that the serial cable is plugged into) in **Port** . 
You can go to "**Files > Examples**" for numerous sample sketches inlcuding helpful comments already provided for you. You can also upload them to Intel Galileo in order to see how things work if you are not familiar with Arduino IDE yet. It is a great way to introduce yourself to Arduino. To upload, click on the **Upload** button. Programs will automatically compile. To compile without uploading, click on the **Verify** button instead. <br><br>
~Center
~~ Figure { #fig-design caption="Upload programs onto Arduino Board" }
![arduino_upload]
~~
~
[arduino_upload]: images/arduino_upload.jpg "arduino_upload" { width=auto max-width=90% }

Note: If you want to add libraries to Arduino IDE, you can just download libraries in a zip file and add libraries by Sketch>Import Library>Add Library. You can use either zip file or folders. If you need more detailed information about how to add additional libraries, you can refer go here. <br> 

Note: Intel Galileo has more than one Serial ports. \
Serial refers to USB Client port. It is responsible to send programs from other devices to Intel Galileo board, and Serial.write() will print out results in Serial Monitor, which can be found in the upper right corner of Arduino IDE. \
Serial1 refers to Pin 0 and Pin 1 in Intel Galileo digital pins. Therefore, when you are programming iRobot using wires connecting Pin 0 and Pin 1 for TX and RX, you have to use Serial1 to talk to iRobot, while you need Serial to enable communication between computer and Intel Galileo. This can be better seen from the chart below:
~Center
~~Figure { #fig-design caption="Corresponding Names of Serial Ports in Arduino IDE" }
![image012]
~~
~
[image012]: images/image012.jpg "image012" { width=auto max-width=90% }

### WiFi Setup
After configuring Intel Galileo with your computer via serial port, we can now advance to enabling wireless communication. This section will walk you through the process of setting up the SD card, installing the WiFi card, creating a locally hosted network on your computer, and connecting the board to it. 

* **Hardware Requirements:** <br>
  - SD card<br>
  - Intel N13 WiFi / Bluetooth 1/2 Length PCI Card <br>
  - Half to Full Height Mini PCI Express (PCI-E) Card Bracket Adapter <br>
  - Two Antennas

* **WiFi Card Setup** \
You can find more detailed instructions from [Intel Galileo: Setting Up WiFi]. The essential steps are as follows: 
[Intel Galileo: Setting Up WiFi]: http://ionospherics.com/intel-galileo-setting-up-wifi/ 


1. Insert two screws to put together _Half to Full Height Mini PCIE Bracket Adapter_ with Intel WiFi card N-135. \
Note: WiFi card N-135 and N-6205 already has their drivers included in the Linux image provided. 
If you are using other WiFi cards, you have to download drivers separately from [here].
[here]: http://wireless.kernel.org/en/users/Drivers/iwlwifi 
2. When your download is complete, Unpack with "tar -xvzf iwlwifi-XXX.tgz", then copy files from your PC to the SD card.
3. Insert card into PCIE connector slot 45 degrees up. Press gently but firmly on the N135 Adapter to seat it on the two hooks on the PCI Connector. Attach antennas to the WiFi card. Insert card into PCIE connector slot 45 degrees up and then pull all the way down.  \
~ Center
~~ Figure { #fig-design caption="WiFi card Setup" }
![image017]
![image040]
~~
~
[image017]: images/image017.jpg "image017" { width=auto max-width=90% }
[image040]: images/image040.jpg "image040" { width=auto max-width=90% }

* **SD Card Setup** \
Since the Flash memory on Intel Galileo, holding the version of Linux used when there is no SD card, is too small to include WiFi drivers, you must have an SD card with Linux image to use WiFi.\
Unzip the Linux image we downloaded in the last section. Plug the SD card into your computer and transfer everything to SD card. Again, preserve the folder structure. \
~Center
~~ Figure { #fig-design caption="SD Card Setup" }
![image018]
~~
~ 
[image018]: images/image018.jpg "image018" { width=auto max-width=90% }
After booting SD card, we can plug it into Intel Galileo, and then we can power on the board through 5V power cable. \
The figure below shows how the commands generated by the processing unit are received over the wireless network using the Intel N-135 wireless receptor that is connected to the Galileo board (Ref. to appendix E.3) and these 
commands are then transmitted to the iRobot via serial communication. \
~Center 
~~Figure { #fig-design caption="Overview of the Data Transfer Flow" }
![image004]
~~
~
[image004]: images/image004.gif "image004" { width=auto max-width=90% }
Now we are ready to create the wireless access point on your computer to complete this communication flow. 
In order to do that, you have to set up network and upload programs through serial port to make Intel Galileo 
ready for WiFi. <br> 

* **WPA Network Setup** \


1. In Windows, search "cmd" (the command prompt) and right click on the icon to "run as administrator", or you will not be able to set up a new network. 
~ Center
~~ Figure {caption="A screenshot from Windows 8.1" }
![run_as_admin]
~~
~
[run_as_admin]: images/run_as_admin.png "run_as_admin" { width=auto max-width=90% }
For Windows 7/Vista, find information from here: [Run a Command as Administrator from the Windows 7 / Vista]. 
[Run a Command as Administrator from the Windows 7 / Vista]: http://www.howtogeek.com/howto/windows-vista/run-a-command-as-administrator-from-the-windows-vista-run-box/

2. In the pop-up window that asks "Do you want to allow the following program to make changes to this computer", click "Yes" to proceed. You will then see the command prompt show up. \
3. Enter: **netsh wlan set hostednetwork mode=allow ssid=yourssid key=yourkey** <br>
Change "**yourssid**" above to the name of the network you are setting up. You can name it whatever you want. 
Change "**yourkey**" above to the password. It should be at least 8 characters long. 
For example, in my case  I set the ssid to "irobot" and key to "irobotirobot". \
Then, enter: **netsh wlan start hostednetwork** \
~Center
~~ Figure { #fig-design caption="Setup hosted network" }
![image021]
~~
~
[image021]: images/image021.jpg "image021" { width=auto max-width=90% }
Note: after you set up this network once on your computer, you can simply enter the last line 
to activate the network that you have previously set up in the future. 

4. You can now check status of network in **Network and Sharing Center**. \
~Center
~~ Figure { #fig-design caption="Status of hosted network" }
![image023]
~~
~
[image023]: images/image023.jpg "image023" { width=auto max-width=90% }
5. Share WiFi with the network that you just created. \
In the left sidebar, choose **Change adapter settings**. Right click on your current network. It is "eduroam 3" WiFi in my case. Click **Properties**. Go to tab **Sharing** and share the network with the network you created. 
~Center 
~~ Figure { #fig-design caption="Change adapter settings" }
![image025]
~~
~
[image025]: images/image025.jpg "image025" { width=auto max-width=90% }
If you run into problems, you can refer to this site for instructions and trouble shooting: 
[Create WiFi hotspot]. \
[Create WiFi hotspot]: http://www.talkofweb.com/creating-wi-fi-hotspot-in-windows-8-share-laptop-internet-connection/

5. Open Arduino IDE. Go to **File>Examples>WiFi>ConnectWithWPA** 
In **char ssid[]**, change "yourNetwork" to your ssid of the network we just set up. 
In **char pass[]**, change "secretPassword" to your password of network. 

7.	Upload the program to Intel Galileo. Then click on **Serial Monitor** in the upper right corner to check status of connection. 

8.	You can find the IP Address in Serial Monitor. It will be used later. 

* **Static IP Setup** \
As you may notice, the IP address that Intel Galileo obtain varies every time it was printed out in the serial monitor. We want to make it static, since we are sending commands via wireless network to a single IP address specific to the board. In order to do that, you have to download PuTTY (or any SSH client that you prefer). 


1. Download PuTTY from [here] and install it. \
[here]: http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html 
~Center
~~ Figure { #fig-design caption="PuTTY download" }
![PuTTY_download]
~~
~
[PuTTY_download]: images/PuTTY_download.jpg "PuTTY_download" { width=auto max-width=90% }
2. Upload this program to Intel Galileo. \
~Center
~~ Figure { #fig-design caption="Connect Intel Galileo with iRobot" }
![image026]
~~
~
[image026]: images/image026.jpg "image026" { width=auto max-width=90% }
3. Then we can use PuTTY for communication between computer and linux image on Intel Galileo. \
We have to first connect an Ethernet cable from computer to Intel Galileo. Next we will open PuTTY to connect to Intel Galileo. Here is a screenshot of my PuTTY configuration:
~Center
~~Figure  {caption="Configuration of Intel Galileo with PuTTY" }
![PuTTY]
~~
~
[PuTTY]: images/PuTTY.png "PuTTY" { width=auto max-width=90% }
You need to manually type in the IP address 169.254.1.1, save it to "Saved Sessions" and load it.
4.	Click "Open" and a command shell will pop out. Log in as "root". Create a backup of your 
/etc/network/interfaces file by typing: \
"cp /etc/network/interfaces  /etc/network/interfaces.backup"

5.	Type "vi /etc/network/interfaces". Press "i" to enter edition mode. Change "dhcp" in the 
"iface wlan0 inet dhcp" line to "static". Comment out all the lines below and add the following lines: \
~Center
~~Figure {caption="A Screenshot of PuTTY" }
![image029]
~~
~
[image029]: images/image029.jpg "image029" { width=auto max-width=90% }
In my case, I set the static IP address to be 192.168.137.10 \
6.	Save the file, and restart the wlan0: \
ifdown wlan0 \
ifup wlan0 \
You can type ":wq" to save and exit vi. 

For more information, you can look at "[How to setup your galileo to have a static IP on a LAN]". 
[How to setup your galileo to have a static IP on a LAN]: https://communities.intel.com/thread/49348 

### Software Setup: Processing and the OpenCV library
As explained in Figure 8 above, we send the keyboard commands from a processing unit on the computer, which is then fetched by Intel Galileo and transfered to iRobot to make it moving. 
Here we will be using Processing, an open source programming language and integrated development 
environment (IDE) built on the Java language but with a simplified syntax and graphics programming 
model, to serve as the processing unit that generates the keyboard commands. As you might have noticed from the startup window of the Arduino IDE software, its design is actually based on Processing, and their user interface is very similar, which makes it very convenient for you to use once you know about Arduino. You can refer to this site "[Connecting Arduino to Processing]"to familiarize yourself with the communication between Arduino IDE and Processing. 

Let's first setup Processing. \
[Connecting Arduino to Processing]: https://learn.sparkfun.com/tutorials/connecting-arduino-to-processing/introduction 
1. Download and install [Processing]. \
~Center 
~~ Figure { #fig-design caption="Processing download" }
![image030]
~~
~
[image030]: images/image030.jpg "image030" { width=auto max-width=90% }
[Processing]: https://www.processing.org/download/?processing 
The installation is similar to that of the Arduino IDE. Simply unzip all files to the C:\ directory. 
2. Install both runtime components for Microsoft Visual Studio [x86] and [x64]. \
[x86]:http://www.microsoft.com/en-us/download/details.aspx?id=5555
[x64]: http://www.microsoft.com/en-us/download/details.aspx?id=14632 
Now you should be able to run the Processing code we provided. 

### Connecting Intel Galileo to iRobot
First, we will provide you a high-level interpretation of the data propagation. 
~Center
~~Figure {caption="Command propagation from the wireless network to the iRobot via the Intel N 135 wireless receptor connected to Galileo board" }
![image041]
~~
~
[image041]: images/image041.png "image041" { width=auto max-width=90% }
For Intel Galileo, the pins are divided into several sections such as DIGITAL, ANALOG, etc. 
If you refer to the picture in the first section, Pin 0 (RXD) and Pin 1 (TXD) are located in DIGITAL section, while the ground power pin is located Pin 6 or Pin 7 of the Power section. You can see these from the datasheet attached below. \
~Center
~~Figure {caption="iRobot Datasheet" }
![image015]
~~
~
[image015]: images/image015.jpg "image015" { width=auto max-width=90% }
There are 25 pins on iRobot as shown below. 
~Center
~~Figure {caption="iRobot Pins" }
![image013]
~~
~
[image013]: images/image013.jpg "image013" { width=auto max-width=90% }

Connect Pin 0 (RXD) on Galileo to Pin 2 on iRobot (Pin 0 on Galileo receives data, while Pin 2 on iRobot sends data). \
Connect Pin 1 (TXD) on Galileo to Pin 1 on iRobot (Pin 1 on Galileo sends data, while Pin 1 on iRobot receives data). \
Connect the GND pin on Galileo to Pin 14 (GND) on iRobot. \
Note: Pins on iRobot range from Pin 1 to Pin 25, while digital pins on Galileo start with Pin 0.\
There are more than 1 GND pins on iRobot. Both of them work.
~Center
~~Figure {caption="Pin Connections between Galileo and iRobot" }
![galileo_irobot_pin_connection]
~~
~
[galileo_irobot_pin_connection]: images/galileo_irobot_pin_connection.jpg "galileo_irobot_pin_connection" { width=auto max-width=90% }

### Running the program
Now we are ready to run the program. 

1. Connect Intel Galileo to your computer with a serial cable. Upload the file 
"*arduinokeyboardControlReception_revised.ino*" to it. (refer to section **3.2.2** above)\
The board will always remember the most recently uploaded sketch. You only need to upload the same file to the board once, if you don't overwrite the sketch afterwards. Every time you power the board on, it starts running the stored sketch. 
2. Unplug Intel Galileo from your computer and connect it to the iRobot. (refer to section **3.2.5** above) \
3. Start the hosted WPA network on your computer (be sure to run the command prompt as Administrator to do so). (refer to section **3.2.5 - WPA network setup - 3** above)\
4. Power on the iRobot. You will see the power light blink and turn green, with a beep sound. \
5. Power on the Intel Galileo. \
_Important Notice_: When the Galileo board is powered on, it automatically starts to run the sketch uploaded to it most recently. 
In the Arduino code, the commands that writes to the iRobot (Op codes to start I/O and set iRobot in full mode) 
are in the setup() method, which is executed at the very beginning for only once before proceeding to the loop() method. If the iRobot is not powered on before the Galileo board, it will miss the setup() and we would not be able to write 
to iRobot. We should power on the iRobot first, then the Galileo board, wait for the power LED on iRobot to turn off (which indicates it has been set to Full Mode), and send commands from the processing unit on our computer. <br><br>
You might want to check the status of the WiFi connection when you try this for the first time. To do so, connect Intel Galileo to your computer through serial cable and open "Serail Monitor" in Arduino IDE to look at the print statements. The sketch prints out the ssid and signal strength of the network. A negative value (instead of 0 dBm) would indicate that the board is successfully connected to the network. The smaller the absolute value is, the stronger the connection. <br><br>
6. After Intel Galileo has joined the network, open the file "*smoothkeyboardincrementer.pde*" in Processing. Click on the "run" button and wait for the socket to show up. If you have the Arduino serial monitor open at this time, you should be able to see a new print statement "We have a new client". 
7. Select on the socket of Processing if you are currently selecting another window. Now you can drive the iRobot with the four direction keys on your keyboard! \

## C++ project for real-time video capture and gesture recognition using Visual Studio, OpenCV libraries and winsock
### Software Setup: Visual Studio and the OpenCV library
1. Download [Visual Studio] and install. 
 [Visual Studio]: https://www.visualstudio.com/products/visual-studio-community-vs 
2. Download [OpenCV] and extract to C:\ directory. \
[OpenCV]: http://opencv.org/downloads.html
~Center
~~ Figure { #fig-design caption="OpenCV library download" }
![image031]
~~
~
[image031]: images/image031.jpg "image031" { width=auto max-width=90% }
We suggest that you download this version of OpenCV, since the code we provide along with this tutorial is configured with OpenCV files in this version of release. If you choose to download another version, make sure to change the "Path" property (which tells the program how to find the library files) before running it. 

For the following steps, you can also refer to this tutorial "[OpenCV on Visual Studio 2013]". \
[OpenCV on Visual Studio 2013]: http://blog.amastaneh.com/2014/03/opencv-on-visual-studio-2013.html 

3. Change Environment Variables. \
Follow the path "My Computer > Properties > Advanced System Settings > Environment Variables > New" and add a new system variable: \
Name: OPENCV_DIR<br>
Value: C:\opencv\build\ (or a similar name if your OpenCV directory has a different name such 
as opencv2.4.9) <br>
Go to "My Computer > Properties > Advanced System Settings > Environment Variables... > System variables", 
select "**Path**" and press "**Edit**" button and add "_;%OPENCV_DIR%\x86\vc12\bin_" \

PS: for Visual Studio 2013 add "_;%OPENCV_DIR%\x86\vc12\bin_" \
PS: for Visual Studio 2012 add "_;%OPENCV_DIR%\x86\vc11\bin_" \

4. \

# Software Implementation
## Arduino
### SmallRobot

For the Arduino code, we installed an additional Adafruit (AF) Motor Shield V2 library, which interfaces with the motor hardware.

In our code, server refers to Intel Galileo while client may refer to Processing, Visual Studio or FPGA. Both the server and the client are connected to the same access point with the client continuously sending data to Intel Galileo over this network. The data sent will be used to set the robot’s speed, direction and turning, and 4 bytes of the data will be needed per configuration. As the data is read byte by byte, the bytes are stored in an array and only used when we have received 4 bytes. After the necessary information to configure the motor is extracted, the data will be replaced by the new data sent by the client.

To ensure that the robot will stop moving immediately after the user removes the red box used to control the robot, it is important there is no delay between the sending of data from the client and the reading of data by Intel Galileo. Hence, the reading of data, _client.read()_, must happen right after the _if (client.available() > 0)_ statement.

To control the robot’s speed, direction and turning, we need to control the spin speed and direction of each of the individual motors attached to the robot’s wheels. However, we want motors on the same side to all have the same speed and direction. Hence, the problem reduces to configuring the left and right side motors.

The motor’s speed is determined by a technique called PulseWidthModulation (PWM) and the AF Motor Shield library expects a PWM value ranging from 0 to 255. A higher PWM value indicates higher spin speed while a lower PWM value indicates otherwise. The motor’s spin direction can be decided simply by setting the motor to run either forward or backward.

To calculate the PWM value for each of the motors, we need to read the 4 bytes of data sent from the client. The first two bytes of data are combined and assigned to the _speed_ variable. The last two bytes of data are also combined and assigned to the _radius_ variable. _speed_ is in two’s complements and is a value between -500 and 500 inclusive. _radius_, on the other hand, will be in the range -550 to 550. In our calculation of motor spin speed and direction, we look at both the magnitude and sign of _speed_ and _radius_.

As the value of _speed_ is in the range of -500 and 500 while the PWM value only ranges from 0 to 255, the map function is used to map the absolute value of _speed_, which gives us a number in the range of 0 to 500, to the range of PWM values. For instance, a _speed_ magnitude of 500 will get mapped to the PWM value of 255. The value returned by the map function is assigned to the variable _pwm_. This _pwm_ value can be viewed as an average of the PWM values for the left and right motors and gives us an indication of the PWM value that the center of the robot should take on. As will be explained later on, the variable _pwm_, combined with _radius_ and the constant ROBOT_HALF_WIDTH, which is the half width of the robot, will help us in determining the PWM value to be assigned to each of the 4 motors controlling the robot’s wheels.

The sign of _speed_ determines whether the motor runs forward or backward. A negative sign translates to backward, a positive sign translates to forward and a speed of 0 translates to release, which is the command to stop the motors. 

The magnitude of _radius_ determines the turning angle. A smaller _radius_ magnitude indicates a sharper turn while a larger _radius_ magnitude indicates a more gradual turn. When the robot is turning, it can be viewed as traveling along an arc of a circle and _radius_ is thus the radius of the circle formed by this arc. The extreme magnitude of 550 is equivalent to no turning. However, having one fixed value to indicate no turning means that if the user does not want the robot to turn, the user will have to hold the red box in exactly the same position as when setting up the red box, which proves to be difficult. Hence, to account for the situation where the user controlling the robot might turn the red box unintentionally, rather than having one fixed value to indicate no turning, we set the range of magnitude from 500 to 550 to indicate no turning. When there is no turning involved, the left and right motors should take on the same PWM values. 

The sign of _radius_ determines the direction of the turn. If the value of _radius_ is positive, the robot is turning left and if it is negative, the robot is turning right.

Combining all these information, the following diagram, which illustrates the case of a robot moving forward and turning left, will help to clarify the calculation of the PWM values for left and right motors.
~Center
~~ Figure { #fig-design caption="Example of robot moving forward and turning left" }
![PWM values]
~~
~
[PWM values]: images/PWM-values.jpg "PWM values" { width=auto max-width=90% }
Based on the diagram, we can use the general idea of ratio to calculate the left and right motor PWM values.
~ Equation {#PWM general}
\frac{distance \ of \ left \ or \ right \ motors \ from \ center \ of \ circle}{distance \ of \ center \ of \ robot \ from \ center \ of \ circle} \cdot PWM \ for \ center \ of \ robot
~
Hence, to calculate the PWM for the left motors, we have
~ Equation {#PWM Left no scale}
\frac{(radius - ROBOT\_HALF\_WIDTH)} {radius} \cdot pwm
~
Similarly, to calculate the PWM for the right motors, we use
~ Equation {#PWM Right no scale}
\frac{(radius \ + \ ROBOT\_HALF\_WIDTH)} {radius} \cdot pwm
~
However, the difference between the PWM values for the left and right motors is not significant to let the robot make a distinct turn. Hence, we scale the difference and the corresponding final equations for calculating the PWM of the left and right motors are
~ Equation {#PWM Left scale}
\frac{(radius \ - \ 2 \cdot ROBOT\_HALF\_WIDTH)} {radius} \cdot pwm
~
~ Equation {#PWM Right scale}
\frac{(radius \ + \ 2 \cdot ROBOT\_HALF\_WIDTH)} {radius} \cdot pwm
~
The results from these equations are assigned to the variables _pwmLeft\_before_ and _pwmRight\_before_. Whenever _radius_ is negative, the fraction in Equation (4) will return a value greater than 1. Whenever _radius_ is positive, the fraction in Equation (5) will return a value greater than 1. If _pwm_ is sufficiently large, there will be the situation when the results calculated from the two equations become greater than 255, which is the maximum PWM value that can be assigned to the motors. We took care of this issue using an if-statement and manually set the PWM value of the motor that exceeded this maximum value to 255. The PWM values for the left and right motors are thus represented by the variables _pwmLeft_ and _pwmRight_ respectively. These values are finally passed in as arguments to set the speed of the motors.

##Visual Studio

Visual Studio, together with OpenCV library, is responsible for converting the video captured by the web camera into information about the velocity, denoted by _velocitySpeed_, and rotation angle, denoted by _rotationAngle_, of the robot before sending the data to Intel Galileo over the network. _velocitySpeed_  and _rotationAngle_ are determined by looking at the size and orientation of the red box held by the user with reference to the startup calibration.

For calculating _velocitySpeed_, the area of the red box is converted to the range of speed that the robot can move at. During the startup calibration, when the user places the red box close to the camera, the area of the red box, _mMax_, is mapped to _alphaMax_, which has the same value as the constant MAX_SPEED_FRONT = 500. Similarly, when the user places the red box further from the camera, the area of the red box, which is now smaller and denoted by _mMin_, is mapped to _alphaMin_, which has the same value as the constant MAX_SPEED_BACK = -500. Later on, when the user moves the box forward and backward to control the robot, the area of the box will be between _mMin_ and _mMax_, and is then converted into a value in the range of _alphaMin_ and _alphaMax_. This value is assigned to _velocitySpeed_ and sent over to Intel Galileo.

For calculating the rotation angle and direction, we made use of OpenCV’s RotatedRect class. The angle, denoted by _l_, is measured from the positive x-axis anti-clockwise to the closest side. This angle increases from -89 to -1 when the box is being rotated left and decreases from -1 to -89 when the box is being rotated right. However, this angle does not tell us the direction of the rotation.

To decide whether the red box is rotated to the left or right, we make use of the width and height of the rotated rectangle. The width of the rotated rectangle does not necessarily correspond to the longer side, but rather, OpenCV sets the side closest to the positive x-axis as the width and the other side as the height by default. Hence, when rotating left, the shorter side is set as the width but when rotating right, the longer side is set as the width. The diagram below illustrates the cases for left and right rotation. 
~Center
~~ Figure { #fig-design caption="Left and Right rotation" }
![rotation angle]
~~
~
[rotation angle]: images/rotation-angle.jpg "rotation angle" { width=auto max-width=90% }
As seen from the diagram, for left rotation, the width is always shorter than the height whereas for right rotation, it is the other way round. Thus, we can compare the width and height of the rotated rectangle to determine if the red box is rotating left or right.

With information about the rotation angle and direction, we can now convert _l_ from the range of -89 to -1 to a value in the range of either MIN_TURN_LEFT=550 to MAX_TURN_LEFT=201 or MIN_TURN_RIGHT=-550 to MAX_TURN_RIGHT=-201 based on the rotation direction. The chosen range is assigned to the variables _betaMax_ and _betaMin_. For example, if the width of the rectangle is shorter than the height, we know that it is a left rotation. Thus, we would set _betaMin_ to MIN_TURN_LEFT and _betaMax_ to MAX_TURN_LEFT. Angle _l_ is then converted to a value between these two numbers and sent to Intel Galileo.

Moving on, in order to gather the above information, we need to detect only the red box from the captured video and eliminate all other distractions in the surrounding.

Firstly, our program will convert the captured video from the RGB color space into the YCbCr color space. YCbCr is a color space that separates the luminance, i.e. light intensity, component of a frame from the hue components. Working in this color space is advantageous over the RGB color space because colors in YCbCr are represented independently from their relative brightness. Note that in a decoded 3-channel image, the channels are stored in the order B, G, R and Y, Cr, Cb. The standard equations for converting an 8-bit image from RGB to YCbCr is given by

~ Equation {#Y}
Y = 0.299 \cdot R + 0.587 \cdot G + 0.114 \cdot B
~

~ Equation {#Cr}
Cr = (R-Y) \cdot 0.713 + 128
~

~Equation {#Cb}
Cb = (B-Y) \cdot 0.564 + 128
~

Next, we will calculate the threshold image using a range of Y, Cb and Cr values that our red box falls within and reject any color other than red.  In this case, the most suitable range for detecting the red box is 0<=Y<=255, 169<=Cr<=255 and 0<=Cb<=255. The input image will be the YCbCr image, which is a 3-channel 8-bit image. Our output image will be the threshold image, which is a 1-channel 8-bit image. This simply means that the output image will be gray scale. In our case, the output image will only consist of either black or white pixels. To find the threshold image, we extracted the YCbCr values of the individual pixels in the input image and compared them with the range of YCbCr values we wanted. If the pixel values fulfill the range, we set its corresponding pixel in the output image to white, represented by the value 255. If it does not fall within the given range, we set the corresponding output pixel to 0, which is black.

In any video processing application, noise is the major component, which we have to deal with. As we are dealing with HD videos with 60 frames per second, noisy red pixels in the video drastically deteriorates the corner detection algorithm’s accuracy. To overcome this issue, we implemented median blur to reject the spurious red pixel on the screen. This time, the input image will be the 1-channel threshold image and the output will also be a 1-channel image. The median blur is achieved by taking the median value of a particular pixel and its neighboring 8 pixels. Since our input image is black and white, the median value will be either 0 or 255. We then assign this median value to the corresponding pixel in the output image. Whenever we encounter a corner pixel or a pixel along the borders, we take the nonexistent neighboring pixel values to be 0 before taking the median.

Using the median blurred threshold image, we called the findContours function in OpenCV to detect the largest contour found in the image. The largest contour is chosen to ensure that we are analyzing the red box, and not any other objects of similar color that might be present in the background. From the contour, we used the minAreaRect function to return the minimum-area bounding rectangle, possibly rotated, and subsequently apply the aforementioned analysis to extract the details about the size and orientation of the rotated rectangle representing the red box.